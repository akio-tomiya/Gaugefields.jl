<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to implement new gauge fields · Gaugefields.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://github.com/akio-tomiya/Gaugefields.jl/howtoimplement/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Gaugefields.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../applications/">Applications</a></li><li><a class="tocitem" href="../usefulfunctions/">Useful functions</a></li><li class="is-active"><a class="tocitem" href>How to implement new gauge fields</a><ul class="internal"><li><a class="tocitem" href="#AbstractGaugefields-and-interfaces"><span>AbstractGaugefields and interfaces</span></a></li><li><a class="tocitem" href="#matrix-field-matrix-field-product"><span>matrix-field matrix-field product</span></a></li><li><a class="tocitem" href="#Several-ways-to-treat-periodic-boundary."><span>Several ways to treat periodic boundary.</span></a></li><li><a class="tocitem" href="#halo-updates"><span>halo updates</span></a></li></ul></li><li><a class="tocitem" href="../measurements/">Measurements</a></li><li><a class="tocitem" href="../mpi/">Parallel computation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>How to implement new gauge fields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How to implement new gauge fields</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/akio-tomiya/Gaugefields.jl/blob/master/docs/src/howtoimplement.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-implement-new-gauge-fields"><a class="docs-heading-anchor" href="#How-to-implement-new-gauge-fields">How to implement new gauge fields</a><a id="How-to-implement-new-gauge-fields-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-implement-new-gauge-fields" title="Permalink"></a></h1><p>It is easy to implement new gauge fields with different internal structures or different parallel computations. </p><h2 id="AbstractGaugefields-and-interfaces"><a class="docs-heading-anchor" href="#AbstractGaugefields-and-interfaces">AbstractGaugefields and interfaces</a><a id="AbstractGaugefields-and-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractGaugefields-and-interfaces" title="Permalink"></a></h2><p>All types of gauge fields belong <code>AbstractGaugefields{NC,Dim}</code>. </p><p>The concrete types for gauge fields should have following functions. </p><ul><li><code>LinearAlgebra.mul!(c::T,a::T1,b::T2) where {T&lt;: AbstractGaugefields,T1 &lt;: Abstractfields,T2 &lt;: Abstractfields}</code></li><li><code>LinearAlgebra.mul!(c::T,a::N,b::T2) where {T&lt;: AbstractGaugefields,N &lt;: Number ,T2 &lt;: Abstractfields}</code></li><li><code>LinearAlgebra.mul!(c::T,a::T1,b::T2,α::Ta,β::Tb) where {T&lt;: AbstractGaugefields,T1 &lt;: Abstractfields,T2 &lt;: Abstractfields,Ta &lt;: Number, Tb &lt;: Number}</code></li><li><code>substitute_U!(a::Array{T1,1},b::Array{T2,1}) where {T1 &lt;: AbstractGaugefields,T2 &lt;: AbstractGaugefields}</code></li><li><code>Base.similar(U::T) where T &lt;: AbstractGaugefields</code></li><li><code>clear_U!(U::T) where T &lt;: AbstractGaugefields</code></li><li><code>set_wing_U!(U::T) where T &lt;: AbstractGaugefields</code></li><li><code>Base.size(U::T) where T &lt;: AbstractGaugefields</code></li><li><code>add_U!(c::T,a::T1) where {T&lt;: AbstractGaugefields,T1 &lt;: Abstractfields}</code></li><li><code>add_U!(c::T,α::N,a::T1) where {T&lt;: AbstractGaugefields,T1 &lt;: Abstractfields, N&lt;:Number}</code></li><li><code>LinearAlgebra.tr(a::T) where T&lt;: Abstractfields</code></li><li><code>LinearAlgebra.tr(a::T,b::T) where T&lt;: Abstractfields</code></li><li><code>Base.setindex!(x::Gaugefields_4D_wing,v,i1,i2,i3,i4,i5,i6)</code></li><li><code>Base.getindex(x::Gaugefields_4D_wing,i1,i2,i3,i4,i5,i6)</code></li></ul><h2 id="matrix-field-matrix-field-product"><a class="docs-heading-anchor" href="#matrix-field-matrix-field-product">matrix-field matrix-field product</a><a id="matrix-field-matrix-field-product-1"></a><a class="docs-heading-anchor-permalink" href="#matrix-field-matrix-field-product" title="Permalink"></a></h2><p><code>LinearAlgebra.mul!(c::T,a::T1,b::T2) where {T&lt;: AbstractGaugefields,T1 &lt;: Abstractfields,T2 &lt;: Abstractfields}</code></p><p>This calculates the matrix-matrix multiplicaetion on each lattice site. </p><p>As a mathematical expression, for matrix-valued fields <span>$A(n), B(n)$</span>, we define &quot;matrix-field matrix-field product&quot; as,</p><p class="math-container">\[[A(n)B(n)]_{ij} = \sum_k [A(n)]_{ik} [B(n)]_{kj}\]</p><p>for all site index n.</p><p>In our package, this is expressed as,</p><pre><code class="language-julia hljs">mul!(C,A,B)</code></pre><p>which means <code>C = A*B</code> on each lattice site.  Here <span>$A, B, C$</span> are same type of <span>$u$</span>.</p><h2 id="Several-ways-to-treat-periodic-boundary."><a class="docs-heading-anchor" href="#Several-ways-to-treat-periodic-boundary.">Several ways to treat periodic boundary.</a><a id="Several-ways-to-treat-periodic-boundary.-1"></a><a class="docs-heading-anchor-permalink" href="#Several-ways-to-treat-periodic-boundary." title="Permalink"></a></h2><p>There are several ways to treat periodic boundary.  Now, there are two kinds of methods, halo updates and direct-shift method. </p><ul><li>halo updates: wing-buffer (so-called halo) type implementations for gauge fields. In this type, there are additional halo sites. If <code>NDW &gt; 0</code> is set, this update is used. </li><li>direct-shift method: In <code>shift_U!</code>  function, the data is copied. If <code>NDW = 0</code> is set, this update is used. </li></ul><p>Therefore, the important functions are </p><ul><li><code>set_wing_U!</code> : This is used in halo updates, but not used in direct-shift method (returns nothing). </li><li><code>shift_U!</code> : In this function, the data is copied in direct-shift method. This is the lazy evaluation in halo updates. </li></ul><h2 id="halo-updates"><a class="docs-heading-anchor" href="#halo-updates">halo updates</a><a id="halo-updates-1"></a><a class="docs-heading-anchor-permalink" href="#halo-updates" title="Permalink"></a></h2><p>There is a wing-buffer (so-called halo) type implementations for gauge fields. In this type, there are additional halo sites.  <code>set_wing_U!</code> function is used for updating halo sites.  If you do not want to use halo type implementations for gauge fields, you can write <code>set_wing_U!(U::Yourtype) = nothing</code>. </p><h3 id="examples"><a class="docs-heading-anchor" href="#examples">examples</a><a id="examples-1"></a><a class="docs-heading-anchor-permalink" href="#examples" title="Permalink"></a></h3><p>We have two kinds of <span>$SU(N)$</span> gauge fields in four dimension. </p><p>Serial version: </p><article class="docstring"><header><a class="docstring-binding" id="Gaugefields.AbstractGaugefields_module.Gaugefields_4D_wing" href="#Gaugefields.AbstractGaugefields_module.Gaugefields_4D_wing"><code>Gaugefields.AbstractGaugefields_module.Gaugefields_4D_wing</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Gaugefields_4D_wing{NC} &lt;: Gaugefields_4D{NC}</code>`</p><p>SU(N) Gauge fields in four dimensional lattice. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/akio-tomiya/Gaugefields.jl/blob/15a2b971c2d1c5809619ff9e2287814eef2248fb/src/4D/wing/gaugefields_4D_wing.jl#L13-L17">source</a></section></article><pre><code class="language-julia hljs">    struct Gaugefields_4D_wing{NC} &lt;: Gaugefields_4D{NC}
        U::Array{ComplexF64,6}
        NX::Int64
        NY::Int64
        NZ::Int64
        NT::Int64
        NDW::Int64
        NV::Int64
        NC::Int64
        mpi::Bool
        verbose_print::Verbose_print

        function Gaugefields_4D_wing(NC::T,NDW::T,NX::T,NY::T,NZ::T,NT::T;verbose_level = 2) where T&lt;: Integer
            NV = NX*NY*NZ*NT
            U = zeros(ComplexF64,NC,NC,NX+2NDW,NY+2NDW,NZ+2NDW,NT+2NDW)
            mpi = false
            verbose_print = Verbose_print(verbose_level )
            #U = Array{Array{ComplexF64,6}}(undef,4)
            #for μ=1:4
            #    U[μ] = zeros(ComplexF64,NC,NC,NX+2NDW,NY+2NDW,NZ+2NDW,NT+2NDW)
            #end
            return new{NC}(U,NX,NY,NZ,NT,NDW,NV,NC,mpi,verbose_print)
        end
    end</code></pre><p>Usually, we do not consider local SU(N) matrix on each lattice bond. The gauge fields are manupulated like </p><pre><code class="language-julia hljs">mul!(C,A,B)
s = tr(C)</code></pre><p>Details of <code>mul!</code> and <code>tr</code> depends on the gauge field type that we use. In other words, the details which depends on kinds of gauge fields are only in the definitions of <code>mul!</code> or <code>tr</code>.  So, we implement kind-dependent <code>mul!</code> like </p><pre><code class="language-julia hljs">    function LinearAlgebra.mul!(c::Gaugefields_4D_wing{NC},a::T1,b::T2) where {NC,T1 &lt;: Abstractfields,T2 &lt;: Abstractfields}
        @assert NC != 2 &amp;&amp; NC != 3 &quot;This function is for NC != 2,3&quot;
        NT = c.NT
        NZ = c.NZ
        NY = c.NY
        NX = c.NX
        @inbounds for it=1:NT
            for iz=1:NZ
                for iy=1:NY
                    for ix=1:NX
                        for k2=1:NC                            
                            for k1=1:NC
                                c[k1,k2,ix,iy,iz,it] = 0

                                @simd for k3=1:NC
                                    c[k1,k2,ix,iy,iz,it] += a[k1,k3,ix,iy,iz,it]*b[k3,k2,ix,iy,iz,it]
                                end
                            end
                        end
                    end
                end
            end
        end
        set_wing_U!(c)
    end</code></pre><p>If we want to use MPI parallel computations, we use diffrent type of gauge fields.  The definition is </p><pre><code class="language-julia hljs">    struct Gaugefields_4D_wing_mpi{NC} &lt;: Gaugefields_4D{NC}
        U::Array{ComplexF64,6}
        NX::Int64
        NY::Int64
        NZ::Int64
        NT::Int64
        NDW::Int64
        NV::Int64
        NC::Int64
        PEs::NTuple{4,Int64}
        PN::NTuple{4,Int64}
        mpiinit::Bool
        myrank::Int64
        nprocs::Int64
        myrank_xyzt::NTuple{4,Int64}
        mpi::Bool
        verbose_print::Verbose_print

        function Gaugefields_4D_wing_mpi(NC::T,NDW::T,NX::T,NY::T,NZ::T,NT::T,PEs;mpiinit=true,
                                                            verbose_level = 2) where T&lt;: Integer
            NV = NX*NY*NZ*NT
            @assert NX % PEs[1] == 0 &quot;NX % PEs[1] should be 0. Now NX = $NX and PEs = $PEs&quot;
            @assert NY % PEs[2] == 0 &quot;NY % PEs[2] should be 0. Now NY = $NY and PEs = $PEs&quot;
            @assert NZ % PEs[3] == 0 &quot;NZ % PEs[3] should be 0. Now NZ = $NZ and PEs = $PEs&quot;
            @assert NT % PEs[4] == 0 &quot;NT % PEs[4] should be 0. Now NT = $NT and PEs = $PEs&quot;

            PN = (NX ÷ PEs[1],
                    NY ÷ PEs[2],
                    NZ ÷ PEs[3],
                    NT ÷ PEs[4],
            )

            if mpiinit == false
                MPI.Init()
                mpiinit = true
            end

            comm = MPI.COMM_WORLD

            nprocs = MPI.Comm_size(comm)
            @assert prod(PEs) == nprocs &quot;num. of MPI process should be prod(PEs). Now nprocs = $nprocs and PEs = $PEs&quot;
            myrank = MPI.Comm_rank(comm)

            verbose_print = Verbose_print(verbose_level,myid = myrank)

            myrank_xyzt = get_myrank_xyzt(myrank,PEs)

            #println(&quot;Hello world, I am $(MPI.Comm_rank(comm)) of $(MPI.Comm_size(comm))&quot;)

            U = zeros(ComplexF64,NC,NC,PN[1]+2NDW,PN[2]+2NDW,PN[3]+2NDW,PN[4]+2NDW)
            #U = Array{Array{ComplexF64,6}}(undef,4)
            #for μ=1:4
            #    U[μ] = zeros(ComplexF64,NC,NC,NX+2NDW,NY+2NDW,NZ+2NDW,NT+2NDW)
            #end
            mpi = true
            return new{NC}(U,NX,NY,NZ,NT,NDW,NV,NC,Tuple(PEs),PN,mpiinit,myrank,nprocs,myrank_xyzt,mpi,verbose_print)
        end
    end</code></pre><p>Its <code>mul!</code> is implemented as </p><pre><code class="language-julia hljs">    function LinearAlgebra.mul!(c::Gaugefields_4D_wing_mpi{NC},a::T1,b::T2) where {NC,T1 &lt;: Abstractfields,T2 &lt;: Abstractfields}
        @assert NC != 2 &amp;&amp; NC != 3 &quot;This function is for NC != 2,3&quot;
        NT = c.NT
        NZ = c.NZ
        NY = c.NY
        NX = c.NX
        PN = c.PN
        for it=1:PN[4]
            for iz=1:PN[3]
                for iy=1:PN[2]
                    for ix=1:PN[1]
                        for k2=1:NC                            
                            for k1=1:NC
                                v = 0
                                setvalue!(c,v,k1,k2,ix,iy,iz,it)
                                #c[k1,k2,ix,iy,iz,it] = 0

                                @simd for k3=1:NC
                                    vc = getvalue(c,k1,k2,ix,iy,iz,it) + getvalue(a,k1,k3,ix,iy,iz,it)*getvalue(b,k3,k2,ix,iy,iz,it)
                                    setvalue!(c,vc,k1,k2,ix,iy,iz,it)
                                    #c[k1,k2,ix,iy,iz,it] += a[k1,k3,ix,iy,iz,it]*b[k3,k2,ix,iy,iz,it]
                                end
                            end
                        end
                    end
                end
            end
        end
        #set_wing_U!(c)
    end
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usefulfunctions/">« Useful functions</a><a class="docs-footer-nextpage" href="../measurements/">Measurements »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 15 September 2025 14:13">Monday 15 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
