var documenterSearchIndex = {"docs":
[{"location":"applications/#Applications","page":"Applications","title":"Applications","text":"","category":"section"},{"location":"applications/#Gradient-flow","page":"Applications","title":"Gradient flow","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"We can use Lüscher's gradient flow.","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"NX = 4\nNY = 4\nNZ = 4\nNT = 4\nNwing = 1\nNC = 3\n\nU = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"hot\")\n\ntemp1 = similar(U[1])\ntemp2 = similar(U[1])\ntemp3 = similar(U[1])\n\ncomb = 6\nfactor = 1/(comb*U[1].NV*U[1].NC)\n\ng = Gradientflow(U)\nfor itrj=1:100\n    flow!(U,g)\n    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n    println(\"$itrj plaq_t = $plaq_t\")\n    poly = calculate_Polyakov_loop(U,temp1,temp2) \n    println(\"$itrj polyakov loop = $(real(poly)) $(imag(poly))\")\nend\n","category":"page"},{"location":"applications/#Heatbath-updates-(even-odd-method)","page":"Applications","title":"Heatbath updates (even-odd method)","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"using Gaugefields\n\n\nfunction heatbath_SU3!(U,NC,temps,β)\n    Dim = 4\n    temp1 = temps[1]\n    temp2 = temps[2]\n    V = temps[3]\n    ITERATION_MAX = 10^5\n\n    temps2 = Array{Matrix{ComplexF64},1}(undef,5) \n    temps3 = Array{Matrix{ComplexF64},1}(undef,5) \n    for i=1:5\n        temps2[i] = zeros(ComplexF64,2,2)\n        temps3[i] = zeros(ComplexF64,NC,NC)\n    end\n\n\n    mapfunc!(A,B) = SU3update_matrix!(A,B,β,NC,temps2,temps3,ITERATION_MAX)\n\n    for μ=1:Dim\n\n        loops = loops_staple[(Dim,μ)]\n        iseven = true\n\n        evaluate_gaugelinks_evenodd!(V,loops,U,[temp1,temp2],iseven)\n        map_U!(U[μ],mapfunc!,V,iseven) \n\n        iseven = false\n        evaluate_gaugelinks_evenodd!(V,loops,U,[temp1,temp2],iseven)\n        map_U!(U[μ],mapfunc!,V,iseven) \n    end\n    \nend\n\nfunction heatbathtest_4D(NX,NY,NZ,NT,β,NC)\n    Dim = 4\n    Nwing = 1\n\n    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    temp3 = similar(U[1])\n\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n    println(\"plaq_t = $plaq_t\")\n    poly = calculate_Polyakov_loop(U,temp1,temp2) \n    println(\"polyakov loop = $(real(poly)) $(imag(poly))\")\n\n    numhb = 40\n    for itrj = 1:numhb\n        heatbath_SU3!(U,NC,[temp1,temp2,temp3],β)\n\n        if itrj % 10 == 0\n            @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n            println(\"$itrj plaq_t = $plaq_t\")\n            poly = calculate_Polyakov_loop(U,temp1,temp2) \n            println(\"$itrj polyakov loop = $(real(poly)) $(imag(poly))\")\n        end\n    end\n    \n\n    return plaq_t\n\nend\n\nNX = 4\nNY = 4\nNZ = 4\nNT = 4\nNwing = 1\n\nβ = 5.7\nNC = 3\n@time plaq_t = heatbathtest_4D(NX,NY,NZ,NT,β,NC)","category":"page"},{"location":"applications/#Wilson-loops","page":"Applications","title":"Wilson loops","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"This package and Wilsonloop.jl enable you to perform several calcurations. Here we demonstrate them.","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"Some of them will be simplified in LatticeQCD.jl.","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"We develop Wilsonloop.jl, which is useful to calculate Wilson loops.  If you want to use this, please install like","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"add Wilsonloop","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"For example, if you want to calculate the following quantity: ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"U_1(n)U_2(n+hat1) U^dagger_1(n+hat2) U^dagger_2(n)","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"You can use Wilsonloop.jl as follows","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"using Wilsonloop\nloop = [(1,1),(2,1),(1,-1),(2,-1)]\nw = Wilsonline(loop)","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"The output is L\"$U_{1}(n)U_{2}(n+e_{1})U^{\\dagger}_{1}(n+e_{2})U^{\\dagger}_{2}(n)$\".  Then, you can evaluate this loop with the use of the Gaugefields.jl like: ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"using LinearAlgebra\nNX = 4\nNY = 4\nNZ = 4\nNT = 4\nNC = 3\nNwing = 1\nDim = 4\nU = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\ntemp1 = similar(U[1])\nV = similar(U[1])\n\nevaluate_gaugelinks!(V,w,U,[temp1])\nprintln(tr(V))","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"For example, if you want to calculate the clover operators, you can define like: ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"function make_cloverloop(μ,ν,Dim)\n    loops = Wilsonline{Dim}[]\n    loop_righttop = Wilsonline([(μ,1),(ν,1),(μ,-1),(ν,-1)],Dim = Dim) # Pmunu\n    push!(loops,loop_righttop)\n    loop_rightbottom = Wilsonline([(ν,-1),(μ,1),(ν,1),(μ,-1)],Dim = Dim) # Qmunu\n    push!(loops,loop_rightbottom)\n    loop_leftbottom= Wilsonline([(μ,-1),(ν,-1),(μ,1),(ν,1)],Dim = Dim) # Rmunu\n    push!(loops,loop_leftbottom)\n    loop_lefttop = Wilsonline([(ν,1),(μ,-1),(ν,-1),(μ,1)],Dim = Dim) # Smunu\n    push!(loops,loop_lefttop)\n    return loops\nend","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"The energy density defined in the paper (Ramos and Sint, Eur. Phys. J. C (2016) 76:15) can be calculated as follows.  Note: the coefficient in the equation (3.40) in the preprint version is wrong. ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"function make_clover(G,U,temps,Dim)\n    temp1 = temps[1]\n    temp2 = temps[2]\n    temp3 = temps[3]\n    \n    for μ=1:Dim\n        for ν=1:Dim\n            if μ == ν\n                continue\n            end\n            loops = make_cloverloop(μ,ν,Dim)\n            evaluate_gaugelinks!(temp3,loops,U,[temp1,temp2])\n\n            Traceless_antihermitian!(G[μ,ν],temp3)\n        end\n    end\nend\n\nfunction calc_energydensity(G,U,temps,Dim)\n    temp1 = temps[1]\n    s = 0\n    for μ=1:Dim\n        for ν=1:Dim\n            if μ == ν\n                continue\n            end\n            mul!(temp1,G[μ,ν],G[μ,ν])\n            s += -real(tr(temp1))/2\n        end\n    end\n    return  s/(4^2*U[1].NV)\nend","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"Then, we can calculate the energy density: ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"function test(NX,NY,NZ,NT,β,NC)\n    Dim = 4\n    Nwing = 1\n\n    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\n    filename = \"./conf_00000010.txt\" \n    L = [NX,NY,NZ,NT]\n    load_BridgeText!(filename,U,L,NC) # We load a configuration from a file. \n\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    temp3 = similar(U[1])\n\n    println(\"Make clover operator\")\n    G = Array{typeof(u1),2}(undef,Dim,Dim)\n    for μ=1:Dim\n        for ν=1:Dim\n            G[μ,ν] = similar(U[1])\n        end\n    end\n\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    @time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n    println(\"plaq_t = $plaq_t\")\n\n    g = Gradientflow(U,eps = 0.01)\n    for itrj=1:100\n        flow!(U,g)\n\n        make_clover(G,U,[temp1,temp2,temp3],Dim)\n        E = calc_energydensity(G,U,[temp1,temp2,temp3],Dim)\n\n        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n        println(\"$itrj $(itrj*0.01) plaq_t = $plaq_t , E = $E\")\n    end\n\nend\nNX = 8\nNY = 8\nNZ = 8\nNT = 8\nβ = 5.7\nNC = 3\ntest(NX,NY,NZ,NT,β,NC)","category":"page"},{"location":"applications/#Calculating-actions","page":"Applications","title":"Calculating actions","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"We can calculate actions from this packages with fixed gauge fields U.  We introduce the concenpt \"Scalar-valued neural network\", which is S(U) -> V, where U and V are gauge fields. ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"using Gaugefields\nusing LinearAlgebra\nfunction test1()\n    NX = 4\n    NY = 4\n    NZ = 4\n    NT = 4\n    Nwing = 1\n    Dim = 4\n    NC = 3\n\n    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\n\n    gauge_action = GaugeAction(U) #empty network\n    plaqloop = make_loops_fromname(\"plaquette\") #This is a plaquette loops. \n    append!(plaqloop,plaqloop') #We need hermitian conjugate loops for making the action real. \n    β = 1 #This is a coefficient.\n    push!(gauge_action,β,plaqloop)\n    \n    show(gauge_action)\n\n    Uout = evaluate_Gaugeaction_untraced(gauge_action,U)\n    println(tr(Uout))\nend\n\ntest1()","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"The output is ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"----------------------------------------------\nStructure of the actions for Gaugefields\nnum. of terms: 1\n-------------------------------\n      1-st term: \n          coefficient: 1.0\n      -------------------------\n1-st loop\nL\"$U_{1}(n)U_{2}(n+e_{1})U^{\\dagger}_{1}(n+e_{2})U^{\\dagger}_{2}(n)$\"\t\n2-nd loop\nL\"$U_{1}(n)U_{3}(n+e_{1})U^{\\dagger}_{1}(n+e_{3})U^{\\dagger}_{3}(n)$\"\t\n3-rd loop\nL\"$U_{1}(n)U_{4}(n+e_{1})U^{\\dagger}_{1}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n4-th loop\nL\"$U_{2}(n)U_{3}(n+e_{2})U^{\\dagger}_{2}(n+e_{3})U^{\\dagger}_{3}(n)$\"\t\n5-th loop\nL\"$U_{2}(n)U_{4}(n+e_{2})U^{\\dagger}_{2}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n6-th loop\nL\"$U_{3}(n)U_{4}(n+e_{3})U^{\\dagger}_{3}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n7-th loop\nL\"$U_{2}(n)U_{1}(n+e_{2})U^{\\dagger}_{2}(n+e_{1})U^{\\dagger}_{1}(n)$\"\t\n8-th loop\nL\"$U_{3}(n)U_{1}(n+e_{3})U^{\\dagger}_{3}(n+e_{1})U^{\\dagger}_{1}(n)$\"\t\n9-th loop\nL\"$U_{4}(n)U_{1}(n+e_{4})U^{\\dagger}_{4}(n+e_{1})U^{\\dagger}_{1}(n)$\"\t\n10-th loop\nL\"$U_{3}(n)U_{2}(n+e_{3})U^{\\dagger}_{3}(n+e_{2})U^{\\dagger}_{2}(n)$\"\t\n11-th loop\nL\"$U_{4}(n)U_{2}(n+e_{4})U^{\\dagger}_{4}(n+e_{2})U^{\\dagger}_{2}(n)$\"\t\n12-th loop\nL\"$U_{4}(n)U_{3}(n+e_{4})U^{\\dagger}_{4}(n+e_{3})U^{\\dagger}_{3}(n)$\"\t\n      -------------------------\n----------------------------------------------\n9216.0 + 0.0im\n","category":"page"},{"location":"applications/#How-to-calculate-derivatives","page":"Applications","title":"How to calculate derivatives","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"We can easily calculate the matrix derivative of the actions. The matrix derivative is defined as ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"left fracpartial Spartial U_mu(n) right_ij = fracpartial Spartial U_mu(n)_ji","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"We can calculate this like ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"dSdUμ = calc_dSdUμ(gauge_action,μ,U)","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"or","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"calc_dSdUμ!(dSdUμ,gauge_action,μ,U)","category":"page"},{"location":"applications/#Hybrid-Monte-Carlo","page":"Applications","title":"Hybrid Monte Carlo","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"With the use of the matrix derivative, we can do the Hybrid Monte Carlo method.  The simple code is as follows. ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"using Gaugefields\nusing LinearAlgebra\n\nfunction MDtest!(gauge_action,U,Dim)\n    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. \n    Uold = similar(U)\n    substitute_U!(Uold,U)\n    MDsteps = 100\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    numaccepted = 0\n\n    numtrj = 100\n    for itrj = 1:numtrj\n        accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)\n        numaccepted += ifelse(accepted,1,0)\n\n        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n        println(\"$itrj plaq_t = $plaq_t\")\n        println(\"acceptance ratio \",numaccepted/itrj)\n    end\nend","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"We define the functions as ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"\nfunction calc_action(gauge_action,U,p)\n    NC = U[1].NC\n    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_Gaugeaction_untraced(gauge_action,U))\n    Sp = p*p/2\n    S = Sp + Sg\n    return real(S)\nend\n\nfunction MDstep!(gauge_action,U,p,MDsteps,Dim,Uold)\n    Δτ = 1/MDsteps\n    gauss_distribution!(p)\n    Sold = calc_action(gauge_action,U,p)\n    substitute_U!(Uold,U)\n\n    for itrj=1:MDsteps\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n\n        P_update!(U,p,1.0,Δτ,Dim,gauge_action)\n\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n    end\n    Snew = calc_action(gauge_action,U,p)\n    println(\"Sold = $Sold, Snew = $Snew\")\n    println(\"Snew - Sold = $(Snew-Sold)\")\n    ratio = min(1,exp(Snew-Sold))\n    if rand() > ratio\n        substitute_U!(U,Uold)\n        return false\n    else\n        return true\n    end\nend\n\nfunction U_update!(U,p,ϵ,Δτ,Dim,gauge_action)\n    temps = get_temporary_gaugefields(gauge_action)\n    temp1 = temps[1]\n    temp2 = temps[2]\n    expU = temps[3]\n    W = temps[4]\n\n    for μ=1:Dim\n        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])\n        mul!(W,expU,U[μ])\n        substitute_U!(U[μ],W)\n        \n    end\nend\n\nfunction P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -> p +factor*U*dSdUμ\n    NC = U[1].NC\n    temps = get_temporary_gaugefields(gauge_action)\n    dSdUμ = temps[end]\n    factor =  -ϵ*Δτ/(NC)\n\n    for μ=1:Dim\n        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)\n        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ\n        Traceless_antihermitian_add!(p[μ],factor,temps[1])\n    end\nend","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"Then, we can do the HMC: ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"function test1()\n    NX = 4\n    NY = 4\n    NZ = 4\n    NT = 4\n    Nwing = 1\n    Dim = 4\n    NC = 3\n\n    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.7/2\n    push!(gauge_action,β,plaqloop)\n    \n    show(gauge_action)\n\n    MDtest!(gauge_action,U,Dim)\n\nend\n\n\ntest1()","category":"page"},{"location":"applications/#Smearing","page":"Applications","title":"Smearing","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"Smearing techniques make gaugefileds more smooth. ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"U_rm fat = cal F(U)","category":"page"},{"location":"applications/#Stout-smearing","page":"Applications","title":"Stout smearing","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"We can use stout smearing. ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"The smearing is regarded as gauge covariant neural networks Tomiya and Nagai, arXiv:2103.11965.  The network is constructed as follows. ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"    nn = CovNeuralnet()\n    ρ = [0.1]\n    layername = [\"plaquette\"]\n    st = STOUT_Layer(layername,ρ,L)\n    push!(nn,st)\n\n    show(nn)","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"The output is ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"num. of layers: 1\n- 1-st layer: STOUT\nnum. of terms: 1\n-------------------------------\n      1-st term: \n          coefficient: 0.1\n      -------------------------\n1-st loop\nL\"$U_{1}(n)U_{2}(n+e_{1})U^{\\dagger}_{1}(n+e_{2})U^{\\dagger}_{2}(n)$\"\t\n2-nd loop\nL\"$U_{1}(n)U_{3}(n+e_{1})U^{\\dagger}_{1}(n+e_{3})U^{\\dagger}_{3}(n)$\"\t\n3-rd loop\nL\"$U_{1}(n)U_{4}(n+e_{1})U^{\\dagger}_{1}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n4-th loop\nL\"$U_{2}(n)U_{3}(n+e_{2})U^{\\dagger}_{2}(n+e_{3})U^{\\dagger}_{3}(n)$\"\t\n5-th loop\nL\"$U_{2}(n)U_{4}(n+e_{2})U^{\\dagger}_{2}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n6-th loop\nL\"$U_{3}(n)U_{4}(n+e_{3})U^{\\dagger}_{3}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n      -------------------------","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"Since we ragard the smearing as the neural networks, we can calculate the derivative with the use of the back propergation techques. ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"<img src=\"https://latex.codecogs.com/svg.image?\\frac{\\partial S}{\\partial U} = G \\left( \\frac{dS}{dU{\\rm fat}},U \\right)\" title=\"\\frac{\\partial S}{\\partial U} = G \\left( \\frac{dS}{dU{\\rm fat}},U \\right)\" />","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"For example, ","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"using Gaugefields\nusing Wilsonloop\n\nfunction stoutsmearing(NX,NY,NZ,NT,NC)\n    Nwing = 1\n    Dim = 4\n    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"hot\")\n    L = [NX,NY,NZ,NT]\n\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n    println(\" plaq_t = $plaq_t\")\n\n\n    nn = CovNeuralnet()\n    ρ = [0.1]\n    layername = [\"plaquette\"]\n    st = STOUT_Layer(layername,ρ,L)\n    push!(nn,st)\n\n    show(nn)\n\n    \n    @time Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    plaq_t = calculate_Plaquette(Uout,temp1,temp2)*factor\n    println(\"plaq_t = $plaq_t\")\n\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.7/2\n    push!(gauge_action,β,plaqloop)\n\n    μ = 1\n    dSdUμ = similar(U)\n    for μ=1:Dim\n        dSdUμ[μ] = calc_dSdUμ(gauge_action,μ,U)\n    end\n\n    @time dSdUbareμ = back_prop(dSdUμ,nn,Uout_multi,U) \n\nend\n\nNX = 4\nNY = 4\nNZ = 4\nNT = 4\nNC = 3\nstoutsmearing(NX,NY,NZ,NT,NC)","category":"page"},{"location":"applications/#HMC-with-stout-smearing","page":"Applications","title":"HMC with stout smearing","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"With the use of the derivatives, we can do the HMC with the stout smearing.  The code is shown as follows","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"using Gaugefields\nusing LinearAlgebra\n\nfunction MDtest!(gauge_action,U,Dim,nn)\n    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. \n    Uold = similar(U)\n    dSdU = similar(U)\n    \n    substitute_U!(Uold,U)\n    MDsteps = 100\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    numaccepted = 0\n    \n\n    numtrj = 100\n    for itrj = 1:numtrj\n        accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)\n        numaccepted += ifelse(accepted,1,0)\n\n        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n        println(\"$itrj plaq_t = $plaq_t\")\n        println(\"acceptance ratio \",numaccepted/itrj)\n    end\nend\n\nfunction calc_action(gauge_action,U,p)\n    NC = U[1].NC\n    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))\n    Sp = p*p/2\n    S = Sp + Sg\n    return real(S)\nend\n\n\nfunction MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)\n    \n\n    Δτ = 1/MDsteps\n    gauss_distribution!(p)\n\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    Sold = calc_action(gauge_action,Uout,p)\n\n    substitute_U!(Uold,U)\n\n    for itrj=1:MDsteps\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n\n        P_update!(U,p,1.0,Δτ,Dim,gauge_action,dSdU,nn)\n\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n    end\n\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    Snew = calc_action(gauge_action,Uout,p)\n\n    println(\"Sold = $Sold, Snew = $Snew\")\n    println(\"Snew - Sold = $(Snew-Sold)\")\n\n    accept = exp(Sold - Snew) >= rand()\n\n    if accept != true #rand() > ratio\n        substitute_U!(U,Uold)\n        return false\n    else\n        return true\n    end\n\nend\n\nfunction U_update!(U,p,ϵ,Δτ,Dim,gauge_action)\n    temps = get_temporary_gaugefields(gauge_action)\n    temp1 = temps[1]\n    temp2 = temps[2]\n    expU = temps[3]\n    W = temps[4]\n\n    for μ=1:Dim\n        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])\n        mul!(W,expU,U[μ])\n        substitute_U!(U[μ],W)\n        \n    end\nend\n\nfunction P_update!(U,p,ϵ,Δτ,Dim,gauge_action,dSdU,nn) # p -> p +factor*U*dSdUμ\n    NC = U[1].NC\n    factor =  -ϵ*Δτ/(NC)\n    temps = get_temporary_gaugefields(gauge_action)\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n\n    for μ=1:Dim\n        calc_dSdUμ!(dSdU[μ],gauge_action,μ,Uout)\n    end\n\n    dSdUbare = back_prop(dSdU,nn,Uout_multi,U) \n    \n    for μ=1:Dim\n        mul!(temps[1],U[μ],dSdUbare[μ]) # U*dSdUμ\n        Traceless_antihermitian_add!(p[μ],factor,temps[1])\n    end\nend\n\nfunction test1()\n    NX = 4\n    NY = 4\n    NZ = 4\n    NT = 4\n    Nwing = 1\n    Dim = 4\n    NC = 3\n\n    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"hot\")\n\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.7/2\n    push!(gauge_action,β,plaqloop)\n\n    show(gauge_action)\n\n    L = [NX,NY,NZ,NT]\n    nn = CovNeuralnet()\n    ρ = [0.1]\n    layername = [\"plaquette\"]\n    st = STOUT_Layer(layername,ρ,L)\n    push!(nn,st)\n\n    \n\n    MDtest!(gauge_action,U,Dim,nn)\n\nend\n\n\ntest1()","category":"page"},{"location":"howtoimplement/#How-to-implement-new-gauge-fields","page":"How to implement new gauge fields","title":"How to implement new gauge fields","text":"","category":"section"},{"location":"howtoimplement/","page":"How to implement new gauge fields","title":"How to implement new gauge fields","text":"It is easy to implement new gauge fields with different internal structures or different parallel computations. ","category":"page"},{"location":"howtoimplement/#AbstractGaugefields","page":"How to implement new gauge fields","title":"AbstractGaugefields","text":"","category":"section"},{"location":"howtoimplement/","page":"How to implement new gauge fields","title":"How to implement new gauge fields","text":"All types of gauge fields belong AbstractGaugefields{NC,Dim}. ","category":"page"},{"location":"howtoimplement/","page":"How to implement new gauge fields","title":"How to implement new gauge fields","text":"The concrete types for gauge fields should have following functions. ","category":"page"},{"location":"howtoimplement/","page":"How to implement new gauge fields","title":"How to implement new gauge fields","text":"LinearAlgebra.mul!(c::T,a::T1,b::T2) where {T<: AbstractGaugefields,T1 <: Abstractfields,T2 <: Abstractfields}\nLinearAlgebra.mul!(c::T,a::N,b::T2) where {T<: AbstractGaugefields,N <: Number ,T2 <: Abstractfields}\nLinearAlgebra.mul!(c::T,a::T1,b::T2,α::Ta,β::Tb) where {T<: AbstractGaugefields,T1 <: Abstractfields,T2 <: Abstractfields,Ta <: Number, Tb <: Number}\nsubstitute_U!(a::Array{T1,1},b::Array{T2,1}) where {T1 <: AbstractGaugefields,T2 <: AbstractGaugefields}\nBase.similar(U::T) where T <: AbstractGaugefields\nclear_U!(U::T) where T <: AbstractGaugefields\nshift_U(U::AbstractGaugefields{NC,Dim},ν) where {NC,Dim}\nset_wing_U!(U::T) where T <: AbstractGaugefields\nBase.size(U::T) where T <: AbstractGaugefields\nadd_U!(c::T,a::T1) where {T<: AbstractGaugefields,T1 <: Abstractfields}\nLinearAlgebra.tr(a::T) where T<: Abstractfields\nLinearAlgebra.tr(a::T,b::T) where T<: Abstractfields","category":"page"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#File-loading","page":"Utilities","title":"File loading","text":"","category":"section"},{"location":"utilities/#ILDG-format","page":"Utilities","title":"ILDG format","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"ILDG format is one of standard formats for LatticeQCD configurations.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"We can read ILDG format like: ","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"NX = 4\nNY = 4\nNZ = 4\nNT = 4\nNwing = 1\nDim = 4\n\nU = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\nildg = ILDG(filename)\ni = 1\nL = [NX,NY,NZ,NT]\nload_gaugefield!(U,i,ildg,L,NC)","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Then, we can calculate the plaquette: ","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"temp1 = similar(U[1])\ntemp2 = similar(U[1])\n\ncomb = 6\nfactor = 1/(comb*U[1].NV*U[1].NC)\n@time plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\nprintln(\"plaq_t = $plaq_t\")\npoly = calculate_Polyakov_loop(U,temp1,temp2) \nprintln(\"polyakov loop = $(real(poly)) $(imag(poly))\")","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"We can write a configuration as the ILDG format like ","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"filename = \"hoge.ildg\"\nsave_binarydata(U,filename)","category":"page"},{"location":"utilities/#Text-format-for-Bridge","page":"Utilities","title":"Text format for Bridge++","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Gaugefields.jl also supports a text format for Bridge++. ","category":"page"},{"location":"utilities/#File-loading-2","page":"Utilities","title":"File loading","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"filename = \"testconf.txt\"\nload_BridgeText!(filename,U,L,NC)","category":"page"},{"location":"utilities/#File-saving","page":"Utilities","title":"File saving","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"filename = \"testconf.txt\"\nsave_textdata(U,filename)","category":"page"},{"location":"utilities/#Data-structure","page":"Utilities","title":"Data structure","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"We can access the gauge field defined on the bond between two neigbohr points.  In 4D system, the gauge field is like u[ic,jc,ix,iy,iz,it].  There are four directions in 4D system. Gaugefields.jl uses the array like: ","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"NX = 4\nNY = 4\nNZ = 4\nNT = 4\nNwing = 1\nDim = 4\n\nU = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"In the later exaples, we use, mu=1 and u=U[mu] as an example.","category":"page"},{"location":"utilities/#Hermitian-conjugate-(Adjoint-operator)","page":"Utilities","title":"Hermitian conjugate (Adjoint operator)","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"If you want to get the hermitian conjugate of the gauge fields, you can do like ","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"u'","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This is evaluated with the lazy evaluation.  So there is no memory copy.  This returms U_mu^dagger for all sites.","category":"page"},{"location":"utilities/#Shift-operator","page":"Utilities","title":"Shift operator","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"If you want to shift the gauge fields, you can do like ","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"shifted_u = shift_U(u, shift)","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This is also evaluated with the lazy evaluation.  Here shift is shift=(1,0,0,0) for example.","category":"page"},{"location":"utilities/#matrix-field-matrix-field-product","page":"Utilities","title":"matrix-field matrix-field product","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"If you want to calculate the matrix-matrix multiplicaetion on each lattice site, you can do like","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"As a mathematical expression, for matrix-valued fields A(n) B(n), we define \"matrix-field matrix-field product\" as,","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"A(n)B(n)_ij = sum_k A(n)_ik B(n)_kj","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"for all site index n.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"In our package, this is expressed as,","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"mul!(C,A,B)","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"which means C = A*B on each lattice site.  Here A B C are same type of u.","category":"page"},{"location":"utilities/#Trace-operation","page":"Utilities","title":"Trace operation","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"If you want to calculate the trace of the gauge field, you can do like ","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"tr(A)","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"It is useful to evaluation actions.  This trace operation summing up all indecis, spacetime and color.","category":"page"},{"location":"usefulfunctions/#Useful-functions","page":"Useful functions","title":"Useful functions","text":"","category":"section"},{"location":"usefulfunctions/#Initializing-gauge-fields.","page":"Useful functions","title":"Initializing gauge fields.","text":"","category":"section"},{"location":"usefulfunctions/","page":"Useful functions","title":"Useful functions","text":"Initialize_Gaugefields","category":"page"},{"location":"#Gaugefields","page":"Home","title":"Gaugefields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Gaugefields","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Gaugefields.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: CI)","category":"page"},{"location":"#Abstract","page":"Home","title":"Abstract","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a package for lattice QCD codes. Treating gauge fields (links), gauge actions with MPI and autograd.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"./LQCDjl_block.png\" width=300>","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package will be used in LatticeQCD.jl. ","category":"page"},{"location":"#What-this-package-can-do:","page":"Home","title":"What this package can do:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has following functionarities","category":"page"},{"location":"","page":"Home","title":"Home","text":"SU(Nc) (Nc > 1) gauge fields in 2 or 4 dimensions with arbitrary actions.\nConfiguration generation\nHeatbath\nquenched Hybrid Monte Carlo\nGradient flow via RK3\nI/O: ILDG and Bridge++ formats are supported (c-lime will be installed implicitly with CLIME_jll )\nMPI parallel computation (experimental. not shown)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dynamical fermions will be supported with LatticeDiracOperators.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, this supports followings","category":"page"},{"location":"","page":"Home","title":"Home","text":"Autograd for functions with SU(Nc) variables\nStout smearing (exp projecting smearing)\nStout force via backpropagation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Autograd can be worked for general Wilson lines except for ones have overlaps.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"add Gaugefields","category":"page"},{"location":"smearing/#Smearing","page":"Smearing","title":"Smearing","text":"","category":"section"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"Smearing techniques make gaugefileds more smooth. ","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"U_rm fat = cal F(U)","category":"page"},{"location":"smearing/#Stout-smearing","page":"Smearing","title":"Stout smearing","text":"","category":"section"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"We can use stout smearing. ","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"The smearing is regarded as gauge covariant neural networks Tomiya and Nagai, arXiv:2103.11965.  The network is constructed as follows. ","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"    nn = CovNeuralnet()\n    ρ = [0.1]\n    layername = [\"plaquette\"]\n    st = STOUT_Layer(layername,ρ,L)\n    push!(nn,st)\n\n    show(nn)","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"The output is ","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"num. of layers: 1\n- 1-st layer: STOUT\nnum. of terms: 1\n-------------------------------\n      1-st term: \n          coefficient: 0.1\n      -------------------------\n1-st loop\nL\"$U_{1}(n)U_{2}(n+e_{1})U^{\\dagger}_{1}(n+e_{2})U^{\\dagger}_{2}(n)$\"\t\n2-nd loop\nL\"$U_{1}(n)U_{3}(n+e_{1})U^{\\dagger}_{1}(n+e_{3})U^{\\dagger}_{3}(n)$\"\t\n3-rd loop\nL\"$U_{1}(n)U_{4}(n+e_{1})U^{\\dagger}_{1}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n4-th loop\nL\"$U_{2}(n)U_{3}(n+e_{2})U^{\\dagger}_{2}(n+e_{3})U^{\\dagger}_{3}(n)$\"\t\n5-th loop\nL\"$U_{2}(n)U_{4}(n+e_{2})U^{\\dagger}_{2}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n6-th loop\nL\"$U_{3}(n)U_{4}(n+e_{3})U^{\\dagger}_{3}(n+e_{4})U^{\\dagger}_{4}(n)$\"\t\n      -------------------------","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"Since we ragard the smearing as the neural networks, we can calculate the derivative with the use of the back propergation techques. ","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"<img src=\"https://latex.codecogs.com/svg.image?\\frac{\\partial S}{\\partial U} = G \\left( \\frac{dS}{dU{\\rm fat}},U \\right)\" title=\"\\frac{\\partial S}{\\partial U} = G \\left( \\frac{dS}{dU{\\rm fat}},U \\right)\" />","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"For example, ","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"using Gaugefields\nusing Wilsonloop\n\nfunction stoutsmearing(NX,NY,NZ,NT,NC)\n    Nwing = 1\n    Dim = 4\n    U = Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"hot\")\n    L = [NX,NY,NZ,NT]\n\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n    println(\" plaq_t = $plaq_t\")\n\n\n    nn = CovNeuralnet()\n    ρ = [0.1]\n    layername = [\"plaquette\"]\n    st = STOUT_Layer(layername,ρ,L)\n    push!(nn,st)\n\n    show(nn)\n\n    \n    @time Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    plaq_t = calculate_Plaquette(Uout,temp1,temp2)*factor\n    println(\"plaq_t = $plaq_t\")\n\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.7/2\n    push!(gauge_action,β,plaqloop)\n\n    μ = 1\n    dSdUμ = similar(U)\n    for μ=1:Dim\n        dSdUμ[μ] = calc_dSdUμ(gauge_action,μ,U)\n    end\n\n    @time dSdUbareμ = back_prop(dSdUμ,nn,Uout_multi,U) \n\nend\n\nNX = 4\nNY = 4\nNZ = 4\nNT = 4\nNC = 3\nstoutsmearing(NX,NY,NZ,NT,NC)","category":"page"},{"location":"smearing/#HMC-with-stout-smearing","page":"Smearing","title":"HMC with stout smearing","text":"","category":"section"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"With the use of the derivatives, we can do the HMC with the stout smearing.  The code is shown as follows","category":"page"},{"location":"smearing/","page":"Smearing","title":"Smearing","text":"using Gaugefields\nusing LinearAlgebra\n\nfunction MDtest!(gauge_action,U,Dim,nn)\n    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. \n    Uold = similar(U)\n    dSdU = similar(U)\n    \n    substitute_U!(Uold,U)\n    MDsteps = 100\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    numaccepted = 0\n    \n\n    numtrj = 100\n    for itrj = 1:numtrj\n        accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)\n        numaccepted += ifelse(accepted,1,0)\n\n        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n        println(\"$itrj plaq_t = $plaq_t\")\n        println(\"acceptance ratio \",numaccepted/itrj)\n    end\nend\n\nfunction calc_action(gauge_action,U,p)\n    NC = U[1].NC\n    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))\n    Sp = p*p/2\n    S = Sp + Sg\n    return real(S)\nend\n\n\nfunction MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU)\n    \n\n    Δτ = 1/MDsteps\n    gauss_distribution!(p)\n\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    Sold = calc_action(gauge_action,Uout,p)\n\n    substitute_U!(Uold,U)\n\n    for itrj=1:MDsteps\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n\n        P_update!(U,p,1.0,Δτ,Dim,gauge_action,dSdU,nn)\n\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n    end\n\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    Snew = calc_action(gauge_action,Uout,p)\n\n    println(\"Sold = $Sold, Snew = $Snew\")\n    println(\"Snew - Sold = $(Snew-Sold)\")\n\n    accept = exp(Sold - Snew) >= rand()\n\n    if accept != true #rand() > ratio\n        substitute_U!(U,Uold)\n        return false\n    else\n        return true\n    end\n\nend\n\nfunction U_update!(U,p,ϵ,Δτ,Dim,gauge_action)\n    temps = get_temporary_gaugefields(gauge_action)\n    temp1 = temps[1]\n    temp2 = temps[2]\n    expU = temps[3]\n    W = temps[4]\n\n    for μ=1:Dim\n        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])\n        mul!(W,expU,U[μ])\n        substitute_U!(U[μ],W)\n        \n    end\nend\n\nfunction P_update!(U,p,ϵ,Δτ,Dim,gauge_action,dSdU,nn) # p -> p +factor*U*dSdUμ\n    NC = U[1].NC\n    factor =  -ϵ*Δτ/(NC)\n    temps = get_temporary_gaugefields(gauge_action)\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n\n    for μ=1:Dim\n        calc_dSdUμ!(dSdU[μ],gauge_action,μ,Uout)\n    end\n\n    dSdUbare = back_prop(dSdU,nn,Uout_multi,U) \n    \n    for μ=1:Dim\n        mul!(temps[1],U[μ],dSdUbare[μ]) # U*dSdUμ\n        Traceless_antihermitian_add!(p[μ],factor,temps[1])\n    end\nend\n\nfunction test1()\n    NX = 4\n    NY = 4\n    NZ = 4\n    NT = 4\n    Nwing = 1\n    Dim = 4\n    NC = 3\n\n    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"hot\")\n\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.7/2\n    push!(gauge_action,β,plaqloop)\n\n    show(gauge_action)\n\n    L = [NX,NY,NZ,NT]\n    nn = CovNeuralnet()\n    ρ = [0.1]\n    layername = [\"plaquette\"]\n    st = STOUT_Layer(layername,ρ,L)\n    push!(nn,st)\n\n    \n\n    MDtest!(gauge_action,U,Dim,nn)\n\nend\n\n\ntest1()","category":"page"}]
}
